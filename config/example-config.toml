# PQCrypta Proxy Configuration
# =============================
# Production-ready HTTP/3/QUIC/WebTransport reverse proxy with hybrid PQC TLS.
#
# All values are configurable - no hardcoded ports, paths, or addresses.
# CLI arguments and environment variables can override these settings.

# =============================
# Server Configuration
# =============================
[server]
# Bind address for QUIC/UDP listener
bind_address = "0.0.0.0"

# Primary UDP port for QUIC/HTTP3/WebTransport (default: 443)
udp_port = 443

# Additional ports to listen on (all support QUIC/HTTP3/WebTransport)
additional_ports = [4433, 4434]

# Maximum concurrent connections
max_connections = 10000

# Maximum concurrent streams per connection
max_streams_per_connection = 1000

# Keep-alive interval in seconds
keepalive_interval_secs = 15

# Maximum idle timeout in seconds
max_idle_timeout_secs = 120

# Enable IPv6 dual-stack binding
enable_ipv6 = false

# Worker threads (0 = auto-detect based on CPU cores)
worker_threads = 0

# =============================
# TLS Configuration
# =============================
[tls]
# Path to TLS certificate chain (PEM format)
cert_path = "/etc/letsencrypt/live/example.com/fullchain.pem"

# Path to TLS private key (PEM format)
key_path = "/etc/letsencrypt/live/example.com/privkey.pem"

# Optional: CA certificate for client verification (mTLS)
# ca_cert_path = "/etc/pqcrypta/ca.pem"

# Require client certificates (mTLS mode)
require_client_cert = false

# ALPN protocols to advertise
alpn_protocols = ["h3", "webtransport"]

# Minimum TLS version (only "1.3" supported for QUIC)
min_version = "1.3"

# Enable OCSP stapling
ocsp_stapling = true

# Certificate reload interval in seconds (0 = disabled)
cert_reload_interval_secs = 3600

# Enable 0-RTT (early data) for faster reconnections
# SECURITY WARNING: 0-RTT is vulnerable to replay attacks!
# Only enable if your application can handle replay protection,
# or if the performance benefit outweighs the security risk.
# Default: false (disabled for security)
enable_0rtt = false

# =============================
# HTTP→HTTPS Redirect Server
# =============================
[http_redirect]
# Enable HTTP redirect server on port 80
enabled = true

# HTTP port (redirects to HTTPS on primary port)
port = 80

# Redirect all HTTP to HTTPS (301 permanent redirect)
redirect_to_https = true

# =============================
# Security Headers
# =============================
# These headers are automatically injected into all responses.
# The Server header is always replaced with "PQCProxy v0.1.0".
[headers]
# HTTP Strict Transport Security (2 years, preload-ready)
hsts = "max-age=63072000; includeSubDomains; preload"

# Prevent clickjacking
x_frame_options = "DENY"

# Prevent MIME-type sniffing
x_content_type_options = "nosniff"

# Control referrer information
referrer_policy = "strict-origin-when-cross-origin"

# Disable browser features (FLoC, camera, microphone, geolocation)
permissions_policy = "camera=(), microphone=(), geolocation=(), interest-cohort=()"

# Cross-origin isolation headers
cross_origin_opener_policy = "same-origin"
cross_origin_embedder_policy = "require-corp"
cross_origin_resource_policy = "same-origin"

# Additional security headers
x_permitted_cross_domain_policies = "none"
x_download_options = "noopen"
x_dns_prefetch_control = "off"

# Custom branding headers (advertise PQC capabilities)
x_quantum_resistant = "ML-KEM-1024, ML-DSA-87, X25519MLKEM768"
x_security_level = "Post-Quantum Ready"

# =============================
# Post-Quantum Cryptography
# =============================
[pqc]
# Enable PQC hybrid key exchange
enabled = true

# PQC provider: "openssl3.5" (requires OpenSSL 3.5+ with OQS provider)
provider = "openssl3.5"

# Path to OpenSSL 3.5 binary (for PQC support)
openssl_path = "/usr/local/openssl-3.5/bin/openssl"

# OpenSSL library path
openssl_lib_path = "/usr/local/openssl-3.5/lib64"

# Preferred KEM algorithm for key exchange
# Options: kyber768, kyber1024, mlkem768, mlkem1024, x25519_kyber768
preferred_kem = "x25519_kyber768"

# Fallback to classical TLS if PQC is unavailable
fallback_to_classical = true

# =============================
# Admin API Configuration
# =============================
[admin]
# Enable admin HTTP API
enabled = true

# Admin API bind address (use 127.0.0.1 for local-only access)
bind_address = "127.0.0.1"

# Admin API port
port = 8081

# Require mTLS for admin API
require_mtls = false

# Optional: Bearer token for admin API authentication
# auth_token = "your-secret-token-here"

# Allowed IP addresses for admin API access
allowed_ips = ["127.0.0.1", "::1"]

# =============================
# Logging Configuration
# =============================
[logging]
# Log level: trace, debug, info, warn, error
level = "info"

# Log format: "json" or "text"
format = "json"

# Log file path (empty = stdout)
# file = "/var/log/pqcrypta-proxy/proxy.log"

# Enable access logs
access_log = true

# Access log file path
# access_log_file = "/var/log/pqcrypta-proxy/access.log"

# =============================
# Rate Limiting (Basic)
# =============================
[rate_limiting]
# Enable basic rate limiting
enabled = true

# Requests per second per IP
requests_per_second = 100

# Burst size for rate limiter
burst_size = 50

# Enable connection rate limiting
connection_rate_limit = true

# New connections per second per IP
connections_per_second = 10

# =============================
# Advanced Multi-Dimensional Rate Limiting
# =============================
# Cutting-edge rate limiting inspired by Cloudflare, Envoy, HAProxy, and Traefik.
# Features: composite keys, JA3 fingerprinting, X-Forwarded-For trust, adaptive ML.

[advanced_rate_limiting]
# Enable advanced rate limiting (overrides basic when enabled)
enabled = true

# IPv6 subnet grouping (64 = /64 subnets treated as single client)
ipv6_subnet_bits = 64

# Trusted proxies for X-Forwarded-For parsing (CIDR or IP)
trusted_proxies = ["10.0.0.0/8", "172.16.0.0/12", "192.168.0.0/16", "127.0.0.1"]

# Key resolution strategy
[advanced_rate_limiting.key_strategy]
# Priority order for key resolution (first found wins)
# Options: source_ip, real_ip, api_key, jwt_subject, ja3_fingerprint, ja4_fingerprint
order = ["api_key", "jwt_subject", "ja3_fingerprint", "real_ip", "source_ip"]

# Fallback key if none found
fallback = "source_ip"

# Enable composite keys (combine multiple keys)
use_composite = false

# Header names for key extraction
[advanced_rate_limiting.headers]
api_key = "X-API-Key"
user_id = "X-User-ID"
tenant_id = "X-Tenant-ID"
real_ip = "X-Real-IP"

# Global limits (DDoS protection layer)
[advanced_rate_limiting.global_limits]
requests_per_second = 100000
burst_size = 50000

[advanced_rate_limiting.global_limits.per_ip]
requests_per_second = 1000
burst_size = 500
requests_per_minute = 30000
requests_per_hour = 500000

[advanced_rate_limiting.global_limits.per_fingerprint]
requests_per_second = 100
burst_size = 50
requests_per_minute = 3000
requests_per_hour = 50000

# JA3/JA4 fingerprint-based limiting (NAT-friendly)
[advanced_rate_limiting.fingerprint_limiting]
enabled = true
prefer_over_ip = false  # Use fingerprint as primary key for NAT scenarios
blocked_fingerprints = []  # Block known malicious fingerprints

# Unknown fingerprint limits (more restrictive)
[advanced_rate_limiting.fingerprint_limiting.unknown_limits]
requests_per_second = 50
burst_size = 25
requests_per_minute = 1500
requests_per_hour = 25000

# Adaptive rate limiting (ML-inspired anomaly detection)
[advanced_rate_limiting.adaptive]
enabled = false  # Disabled by default, enable for production
baseline_window_secs = 3600  # 1 hour baseline learning
sensitivity = 0.7
auto_adjust = false
min_samples = 1000
std_dev_multiplier = 3.0  # Requests > mean + 3*std_dev = anomaly

# Per-route rate limits (uncomment to enable)
# Each route can have its own rate limits with optional key override and exemptions

# [advanced_rate_limiting.route_limits.api_heavy]
# pattern = "/api/heavy"                    # Route pattern (path prefix or regex)
# key_override = "api_key"                  # Override key resolution for this route
# exempt_keys = ["internal-service-key"]    # Keys exempt from rate limiting
# [advanced_rate_limiting.route_limits.api_heavy.limits]
# requests_per_second = 10
# burst_size = 5
# requests_per_minute = 300
# requests_per_hour = 5000

# [advanced_rate_limiting.route_limits.public_api]
# pattern = "/api/public/.*"
# [advanced_rate_limiting.route_limits.public_api.limits]
# requests_per_second = 50
# burst_size = 25
# requests_per_minute = 1500

# Composite key configuration (combine multiple keys for rate limiting)
# Useful for tenant-aware rate limiting or complex scenarios

# [[advanced_rate_limiting.composite_keys]]
# name = "tenant-user"                      # Name for logging/metrics
# keys = ["header:X-Tenant-ID", "jwt_subject"]  # Keys to combine
# routes = ["/api/.*"]                      # Routes this applies to (empty = all)
# [advanced_rate_limiting.composite_keys.limits]
# requests_per_second = 500
# burst_size = 250
# requests_per_minute = 15000
# requests_per_hour = 250000

# [[advanced_rate_limiting.composite_keys]]
# name = "ip_plus_path"
# keys = ["source_ip", "path"]
# routes = []                               # Empty = all routes
# [advanced_rate_limiting.composite_keys.limits]
# requests_per_second = 50
# burst_size = 25

# =============================
# Security Settings
# =============================
[security]
# Maximum request body size in bytes (10MB default)
max_request_size = 10485760

# Maximum header size in bytes (64KB default)
max_header_size = 65536

# Connection timeout in seconds
connection_timeout_secs = 30

# Enable DoS protection
dos_protection = true

# Blocked IP addresses
blocked_ips = []

# Allowed IP addresses (whitelist mode - empty = allow all)
allowed_ips = []

# GeoIP database path for country blocking (optional)
# geoip_db_path = "/var/www/html/pqcrypta-proxy/data/geoip/GeoLite2-City.mmdb"

# Blocked country codes (ISO 3166-1 alpha-2)
blocked_countries = []  # e.g., ["CN", "RU", "KP", "IR"]

# Maximum connections per IP
max_connections_per_ip = 100

# Error-based blocking thresholds (prevents false positives from scanners)
error_4xx_threshold = 100          # 4xx errors before checking rate
min_requests_for_error_check = 200 # Minimum requests before error check
error_rate_threshold = 0.7         # 70% error rate triggers suspicious pattern
error_window_secs = 60             # Sliding window duration (seconds)
auto_block_threshold = 10          # Suspicious patterns before auto-block
auto_block_duration_secs = 300     # Block duration (seconds)

# =============================
# TLS Fingerprint Detection (JA3/JA4)
# =============================
[fingerprint]
# Enable TLS fingerprint detection
enabled = true

# Block duration for malicious fingerprints (seconds)
malicious_block_duration_secs = 3600   # 1 hour

# Block duration for suspicious fingerprints with high request rate (seconds)
suspicious_block_duration_secs = 300   # 5 minutes

# Request count threshold to trigger suspicious fingerprint rate check
suspicious_rate_threshold = 100

# Time window for suspicious rate detection (seconds)
suspicious_rate_window_secs = 60       # 1 minute

# Fingerprint cache max age before cleanup (seconds)
cache_max_age_secs = 3600              # 1 hour

# =============================
# Circuit Breaker Configuration
# =============================
[circuit_breaker]
# Enable circuit breaker for backend protection
enabled = true

# Time before circuit breaker transitions from Open to Half-Open (seconds)
half_open_delay_secs = 30

# Maximum test requests allowed in Half-Open state
half_open_max_requests = 3

# Failure threshold to open the circuit
failure_threshold = 5

# Success threshold to close the circuit from Half-Open
success_threshold = 2

# Stale request counter cleanup interval (seconds)
stale_counter_cleanup_secs = 300       # 5 minutes

# =============================
# HTTP Connection Pool Configuration
# =============================
[connection_pool]
# Pool idle timeout - how long idle connections stay in pool (seconds)
idle_timeout_secs = 90

# Maximum idle connections per backend host
max_idle_per_host = 10

# Maximum total connections per backend host
max_connections_per_host = 100

# Connection acquire timeout (milliseconds)
acquire_timeout_ms = 5000              # 5 seconds

# =============================
# Load Balancer Configuration
# =============================
# Configure load balancing for backend pools with multiple servers.
# Supports: least_connections (default), round_robin, weighted_round_robin,
#           random, ip_hash, least_response_time

[load_balancer]
# Enable load balancing (automatically enabled when backend_pools defined)
enabled = true

# Default algorithm for all pools (can be overridden per-pool)
# Options: least_connections, round_robin, weighted_round_robin, random, ip_hash, least_response_time
default_algorithm = "least_connections"

# Session affinity (sticky sessions) configuration
[load_balancer.session_affinity]
# Enable session affinity globally
enabled = false
# Cookie name for session tracking
cookie_name = "PQCPROXY_BACKEND"
# Cookie TTL in seconds (0 = session cookie)
cookie_ttl_secs = 3600
# Use secure cookies (HTTPS only)
cookie_secure = true
# Use HttpOnly cookies (prevent XSS access)
cookie_httponly = true
# SameSite attribute: strict, lax, none
cookie_samesite = "lax"

# Request queue for when all backends are saturated
[load_balancer.queue]
enabled = true
max_size = 1000
timeout_ms = 5000

# Slow start for recovering backends (gradual traffic increase)
[load_balancer.slow_start]
enabled = true
duration_secs = 30
initial_weight_percent = 10

# Connection draining for graceful backend removal
[load_balancer.connection_draining]
enabled = true
timeout_secs = 30

# =============================
# Backend Pools (Load Balanced)
# =============================
# Backend pools define multiple servers for load balancing.
# Routes can reference pools by name just like single backends.
# Pools take priority over single backends with the same name.

# Example: API pool with 3 servers using least_connections
[backend_pools.api-pool]
name = "api-pool"
algorithm = "least_connections"  # Override default algorithm
health_aware = true              # Skip unhealthy backends
affinity = "none"                # Options: none, cookie, ip_hash, header
# affinity_header = "X-Session-ID"  # Header name when affinity = "header"
# queue_max_size = 500             # Pool-specific queue size (overrides global)
# queue_timeout_ms = 3000          # Pool-specific queue timeout (overrides global)
health_check_path = "/health"
health_check_interval_secs = 10

[[backend_pools.api-pool.servers]]
address = "127.0.0.1:3003"
weight = 100          # For weighted algorithms
priority = 1          # Lower = higher priority for failover
max_connections = 100
timeout_ms = 30000
tls_mode = "terminate"

[[backend_pools.api-pool.servers]]
address = "127.0.0.1:3004"
weight = 100
priority = 1
max_connections = 100
timeout_ms = 30000
tls_mode = "terminate"

[[backend_pools.api-pool.servers]]
address = "10.0.0.5:3003"
weight = 50           # Half the traffic (weighted algorithms)
priority = 2          # Failover only (used when priority 1 servers down)
max_connections = 50
timeout_ms = 30000
tls_mode = "terminate"

# Example: Apache pool with IP hash for session stickiness
[backend_pools.apache-pool]
name = "apache-pool"
algorithm = "ip_hash"   # Consistent hashing by client IP
health_aware = true
affinity = "ip_hash"    # Built-in IP-based stickiness
health_check_path = "/health"
health_check_interval_secs = 10

[[backend_pools.apache-pool.servers]]
address = "127.0.0.1:8080"
weight = 100
priority = 1
max_connections = 200

[[backend_pools.apache-pool.servers]]
address = "127.0.0.1:8081"
weight = 100
priority = 1
max_connections = 200

# Example: Session pool with cookie-based sticky sessions
[backend_pools.session-pool]
name = "session-pool"
algorithm = "round_robin"
health_aware = true
affinity = "cookie"     # Cookie-based sticky sessions
health_check_path = "/health"
health_check_interval_secs = 10

[[backend_pools.session-pool.servers]]
address = "192.168.1.10:8000"
weight = 100
priority = 1
max_connections = 100

[[backend_pools.session-pool.servers]]
address = "192.168.1.11:8000"
weight = 100
priority = 1
max_connections = 100

# Example: Pool with header-based affinity and TLS to backends
[backend_pools.secure-pool]
name = "secure-pool"
algorithm = "round_robin"
health_aware = true
affinity = "header"                    # Header-based sticky sessions
affinity_header = "X-Session-ID"       # Required when affinity = "header"
queue_max_size = 200                   # Pool-specific queue max size
queue_timeout_ms = 2000                # Pool-specific queue timeout
health_check_path = "/health"
health_check_interval_secs = 15

# Pool server with TLS re-encryption to backend
[[backend_pools.secure-pool.servers]]
address = "10.0.0.50:443"
weight = 100
priority = 1
max_connections = 50
timeout_ms = 30000
tls_mode = "reencrypt"                 # TLS to backend
tls_cert = "/etc/pqcrypta/backend-ca.pem"  # CA cert for verification
tls_skip_verify = false                # DANGEROUS if true - only for testing
tls_sni = "backend1.internal.com"      # Custom SNI hostname

[[backend_pools.secure-pool.servers]]
address = "10.0.0.51:443"
weight = 100
priority = 1
max_connections = 50
timeout_ms = 30000
tls_mode = "reencrypt"
tls_cert = "/etc/pqcrypta/backend-ca.pem"
tls_skip_verify = false
tls_sni = "backend2.internal.com"

# =============================
# Backend Definitions (Single)
# =============================
# Backends support three TLS modes:
#   - terminate (default): TLS terminates at proxy, plain HTTP to backend
#   - reencrypt: TLS terminates at proxy, new HTTPS connection to backend
#   - passthrough: No TLS termination, SNI-based routing (see [[passthrough_routes]])

# Apache/PHP backend (TLS Terminate - default)
[backends.apache]
name = "apache"
type = "http1"
address = "127.0.0.1:8080"
tls_mode = "terminate"  # Default - can be omitted
timeout_ms = 30000
max_connections = 100
health_check = "/health"
health_check_interval_secs = 30

# Rust API backend (TLS Terminate)
[backends.api]
name = "api"
type = "http1"
address = "127.0.0.1:3003"
tls_mode = "terminate"
timeout_ms = 30000
max_connections = 100
health_check = "/health"
health_check_interval_secs = 30

# Internal HTTPS API (TLS Re-encrypt with mTLS)
[backends.internal-api]
name = "internal-api"
type = "http1"
address = "internal.example.com:443"
tls_mode = "reencrypt"
# Custom CA for backend certificate verification
tls_cert = "/etc/pqcrypta/internal-ca.pem"
# mTLS client certificate (optional)
tls_client_cert = "/etc/pqcrypta/client.pem"
tls_client_key = "/etc/pqcrypta/client.key"
# DANGEROUS: Only set true for testing
tls_skip_verify = false
# Custom SNI hostname (optional)
tls_sni = "internal.example.com"
timeout_ms = 30000
max_connections = 50
health_check = "/health"
health_check_interval_secs = 30

# PHP-FPM backend via Unix socket
[backends.php]
name = "php"
type = "unix"
address = "unix:/run/php-fpm.sock"
timeout_ms = 30000
max_connections = 100
health_check = "/health"
health_check_interval_secs = 30

# HTTP/2 backend with TLS
[backends.http2-backend]
name = "http2-backend"
type = "http2"
address = "api.internal.example.com:443"
tls_mode = "reencrypt"
tls_skip_verify = false
timeout_ms = 30000
max_connections = 50
health_check = "/health"
health_check_interval_secs = 30

# HTTP/3 backend (QUIC to QUIC)
[backends.quic-backend]
name = "quic-backend"
type = "http3"
address = "backend.example.com:4433"
tls_mode = "reencrypt"
timeout_ms = 30000
max_connections = 50

# Raw TCP backend
[backends.tcp-service]
name = "tcp-service"
type = "tcp"
address = "127.0.0.1:9000"
timeout_ms = 10000
max_connections = 100

# =============================
# TLS Passthrough Routes (SNI Routing)
# =============================
# These routes bypass TLS termination entirely.
# Traffic is routed based on SNI (Server Name Indication) without decryption.
# Use for services that must handle their own TLS or require end-to-end encryption.

# External service with SNI routing
[[passthrough_routes]]
name = "external-mail"
sni = "mail.example.com"
backend = "10.0.0.10:443"
proxy_protocol = false  # Enable for client IP preservation
timeout_ms = 30000

# Wildcard SNI routing (matches *.internal.example.com)
[[passthrough_routes]]
name = "internal-wildcard"
sni = "*.internal.example.com"
backend = "10.0.0.20:443"
proxy_protocol = true
timeout_ms = 30000

# Legacy service requiring passthrough
[[passthrough_routes]]
name = "legacy-service"
sni = "legacy.example.com"
backend = "192.168.1.100:443"
timeout_ms = 60000

# =============================
# Route Configuration
# =============================
# Routes are matched by priority (lower = higher priority).
# Routes support: domain matching, path matching, CORS, redirects, headers override.

# API subdomain route with CORS
[[routes]]
name = "api-route"
host = "api.example.com"
path_prefix = "/"
backend = "api"
forward_client_identity = true
client_identity_header = "X-Client-IP"
priority = 100

[routes.cors]
allow_origin = "https://example.com"
allow_methods = ["GET", "POST", "PUT", "DELETE", "OPTIONS"]
allow_headers = ["Content-Type", "Authorization", "X-API-Key", "X-Request-ID"]
allow_credentials = true
max_age = 86400

[routes.add_headers]
X-Forwarded-Proto = "https"
X-API-Version = "v1"

# Main site route (Apache backend)
[[routes]]
name = "main-site"
host = "example.com"
path_prefix = "/"
backend = "apache"
forward_client_identity = true
priority = 100

# www redirect to non-www
[[routes]]
name = "www-redirect"
host = "www.example.com"
path_prefix = "/"
redirect = "https://example.com"
redirect_permanent = true
priority = 1

# Internal API route (TLS re-encrypt)
[[routes]]
name = "internal-api-route"
host = "example.com"
path_prefix = "/internal-api"
backend = "internal-api"
forward_client_identity = true
priority = 50

# SEO redirect: underscore to hyphen
[[routes]]
name = "seo-old-path"
host = "example.com"
path_prefix = "/old_path"
redirect = "/new-path"
redirect_permanent = true
priority = 1

# SEO redirect: legacy URL
[[routes]]
name = "seo-legacy"
host = "example.com"
path_prefix = "/legacy_page"
redirect = "/modern-page"
redirect_permanent = true
priority = 1

# WebTransport route for real-time encryption
[[routes]]
name = "webtransport-encrypt"
host = "api.example.com"
path_prefix = "/encrypt"
webtransport = true
backend = "api"
stream_to_method = "POST"
forward_client_identity = true
priority = 10

[routes.add_headers]
X-WebTransport = "true"

# WebTransport route for streaming
[[routes]]
name = "webtransport-stream"
host = "api.example.com"
path_prefix = "/stream"
webtransport = true
backend = "api"
stream_to_method = "POST"
forward_client_identity = true
priority = 10

# Route with custom headers override
[[routes]]
name = "custom-headers"
host = "example.com"
path_prefix = "/embed"
backend = "apache"
priority = 50

# Override global security headers for this route
[routes.headers_override]
x_frame_options = "SAMEORIGIN"  # Allow embedding from same origin
cross_origin_embedder_policy = "unsafe-none"  # Disable for legacy content

# PHP-FPM route
[[routes]]
name = "php-route"
host = "example.com"
path_prefix = "/app"
backend = "php"
forward_client_identity = true
priority = 80

# Regex path matching (requires path_regex instead of path_prefix)
[[routes]]
name = "api-versioned"
host = "api.example.com"
path_regex = "^/v[0-9]+/.*"
backend = "api"
forward_client_identity = true
priority = 20

# Exact path match (stricter than path_prefix)
[[routes]]
name = "exact-health"
host = "api.example.com"
path_exact = "/health"             # Only matches /health exactly, not /health/db
backend = "api"
priority = 5

# Route with headers removal
[[routes]]
name = "sanitized-api"
host = "api.example.com"
path_prefix = "/public"
backend = "api"
forward_client_identity = true
priority = 60
remove_headers = ["X-Internal-Token", "X-Debug-Info"]  # Headers to strip before sending to backend

[routes.add_headers]
X-Public-Request = "true"

# Route allowing HTTP/1.1 (for search bots like Googlebot that don't support HTTP/3)
[[routes]]
name = "seo-friendly"
host = "example.com"
path_prefix = "/sitemap"
backend = "apache"
allow_http11 = true                # Allow HTTP/1.1 for this route (search bots)
skip_bot_blocking = true           # Don't block bots on this route
priority = 30

# Route with Stripe.js compatibility (removes COEP/COOP headers that break Stripe)
[[routes]]
name = "checkout-page"
host = "example.com"
path_prefix = "/checkout"
backend = "apache"
stripe_compatibility = true        # Removes Cross-Origin-Embedder-Policy and Cross-Origin-Opener-Policy
priority = 40

# Route with custom timeout override
[[routes]]
name = "long-running-api"
host = "api.example.com"
path_prefix = "/export"
backend = "api"
timeout_override_ms = 120000       # 2 minute timeout for long exports
forward_client_identity = true
priority = 45

# Wildcard catch-all route
[[routes]]
name = "default"
path_prefix = "/"
backend = "apache"
priority = 1000

# =============================
# Configuration Notes
# =============================

# TLS Modes Explained:
# --------------------
# 1. TERMINATE (default): TLS terminates at proxy
#    - Client ←(HTTPS)→ Proxy ←(HTTP)→ Backend
#    - Most common mode for internal backends
#    - Proxy can inspect/modify traffic
#
# 2. REENCRYPT: TLS terminates and re-establishes
#    - Client ←(HTTPS)→ Proxy ←(HTTPS)→ Backend
#    - Use for backends requiring end-to-end encryption
#    - Supports mTLS for mutual authentication
#    - Proxy can still inspect traffic
#
# 3. PASSTHROUGH: No TLS termination (SNI routing)
#    - Client ←(HTTPS)→ Proxy ←(HTTPS)→ Backend (same TLS session)
#    - Use for services handling their own TLS
#    - Proxy cannot inspect traffic
#    - Configured via [[passthrough_routes]], not backends

# Security Headers:
# -----------------
# The proxy automatically injects security headers from [headers] section.
# The Server header is always replaced with "PQCProxy v0.1.0" to hide
# backend identity (Apache, nginx, etc.).

# CORS Handling:
# --------------
# When [routes.cors] is configured:
# - OPTIONS preflight requests are handled automatically
# - CORS headers are added to all responses
# - Credentials and custom headers supported

# HTTP Redirect:
# --------------
# When [http_redirect] is enabled:
# - Port 80 redirects all requests to HTTPS
# - Uses 301 (permanent) redirect
# - Preserves path and query string

# Alt-Svc Advertisement:
# ----------------------
# All responses include Alt-Svc header advertising HTTP/3:
#   Alt-Svc: h3=":443"; ma=86400, h3=":4433"; ma=86400, h3=":4434"; ma=86400

# Hot Reload:
# -----------
# Configuration can be reloaded without restart:
#   curl -X POST http://127.0.0.1:8081/reload
# TLS certificates can be reloaded separately:
#   curl -X POST http://127.0.0.1:8081/reload -d '{"tls_only":true}'

# Route Options Reference:
# ------------------------
# Path Matching (use one):
#   - path_prefix: Matches if path starts with value (e.g., "/api" matches "/api/v1")
#   - path_exact: Matches only the exact path (e.g., "/health" won't match "/health/db")
#   - path_regex: Regex pattern for complex matching (e.g., "^/v[0-9]+/.*")
#
# Headers:
#   - add_headers: Headers to add to backend request
#   - remove_headers: Headers to strip before sending to backend
#   - headers_override: Override global security headers for this route
#
# Special Modes:
#   - allow_http11: Allow HTTP/1.1 for search bots (Googlebot doesn't support HTTP/3)
#   - skip_bot_blocking: Don't apply bot protection to this route
#   - stripe_compatibility: Removes COEP/COOP headers that break Stripe.js
#   - timeout_override_ms: Custom timeout for slow endpoints
#
# Backend Pool Options:
# ---------------------
#   - affinity: Session stickiness mode (none, cookie, ip_hash, header)
#   - affinity_header: Header name when affinity = "header"
#   - queue_max_size: Pool-specific queue size (overrides [load_balancer.queue])
#   - queue_timeout_ms: Pool-specific queue timeout
#
# Pool Server TLS Options:
# ------------------------
#   - tls_mode: terminate, reencrypt, or passthrough
#   - tls_cert: CA certificate for backend verification
#   - tls_skip_verify: Skip verification (DANGEROUS - testing only)
#   - tls_sni: Custom SNI hostname for TLS handshake
